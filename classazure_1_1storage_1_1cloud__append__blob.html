<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Microsoft Azure Storage Client Library for C++: azure::storage::cloud_append_blob Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Microsoft Azure Storage Client Library for C++
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">The Microsoft Azure Storage Client Library for C++ is a library for working with the Azure Storage Services in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>azure</b></li><li class="navelem"><b>storage</b></li><li class="navelem"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html">cloud_append_blob</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classazure_1_1storage_1_1cloud__append__blob-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">azure::storage::cloud_append_blob Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a Windows Azure append blob.  
 <a href="classazure_1_1storage_1_1cloud__append__blob.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for azure::storage::cloud_append_blob:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classazure_1_1storage_1_1cloud__append__blob.png" usemap="#azure::storage::cloud_append_blob_map" alt=""/>
  <map id="azure::storage::cloud_append_blob_map" name="azure::storage::cloud_append_blob_map">
<area href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_..." alt="azure::storage::cloud_blob" shape="rect" coords="0,0,209,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad38afb33d45bc6ae56ac00a802ad87bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ad38afb33d45bc6ae56ac00a802ad87bc">cloud_append_blob</a> ()</td></tr>
<tr class="memdesc:ad38afb33d45bc6ae56ac00a802ad87bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class.  <a href="#ad38afb33d45bc6ae56ac00a802ad87bc">More...</a><br /></td></tr>
<tr class="separator:ad38afb33d45bc6ae56ac00a802ad87bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852aabfcdd284ca06e4824a3088115d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aa852aabfcdd284ca06e4824a3088115d">cloud_append_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>)</td></tr>
<tr class="memdesc:aa852aabfcdd284ca06e4824a3088115d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob.  <a href="#aa852aabfcdd284ca06e4824a3088115d">More...</a><br /></td></tr>
<tr class="separator:aa852aabfcdd284ca06e4824a3088115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8424620abebc620726cd7c5a11c51e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ace8424620abebc620726cd7c5a11c51e">cloud_append_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>, <a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a> credentials)</td></tr>
<tr class="memdesc:ace8424620abebc620726cd7c5a11c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob.  <a href="#ace8424620abebc620726cd7c5a11c51e">More...</a><br /></td></tr>
<tr class="separator:ace8424620abebc620726cd7c5a11c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2576168deaad055d2d15169dba3dd00a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a2576168deaad055d2d15169dba3dd00a">cloud_append_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>, utility::string_t <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a68c895693f527a1148fa6abc8672c626">snapshot_time</a>, <a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a> credentials)</td></tr>
<tr class="memdesc:a2576168deaad055d2d15169dba3dd00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob.  <a href="#a2576168deaad055d2d15169dba3dd00a">More...</a><br /></td></tr>
<tr class="separator:a2576168deaad055d2d15169dba3dd00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa791ddcad0cebc6803c11b68f7652dd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aa791ddcad0cebc6803c11b68f7652dd9">cloud_append_blob</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;blob)</td></tr>
<tr class="memdesc:aa791ddcad0cebc6803c11b68f7652dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class.  <a href="#aa791ddcad0cebc6803c11b68f7652dd9">More...</a><br /></td></tr>
<tr class="separator:aa791ddcad0cebc6803c11b68f7652dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3c9470de3853b0546074c5162d44d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aea3c9470de3853b0546074c5162d44d9">create_or_replace</a> ()</td></tr>
<tr class="memdesc:aea3c9470de3853b0546074c5162d44d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a>  <a href="#aea3c9470de3853b0546074c5162d44d9">More...</a><br /></td></tr>
<tr class="separator:aea3c9470de3853b0546074c5162d44d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5846f51c58f062a8ee2fd9eb2106f31c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a5846f51c58f062a8ee2fd9eb2106f31c">create_or_replace</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a5846f51c58f062a8ee2fd9eb2106f31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a>  <a href="#a5846f51c58f062a8ee2fd9eb2106f31c">More...</a><br /></td></tr>
<tr class="separator:a5846f51c58f062a8ee2fd9eb2106f31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359929efe289961523d8b4c77c68f80d"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a359929efe289961523d8b4c77c68f80d">create_or_replace_async</a> ()</td></tr>
<tr class="memdesc:a359929efe289961523d8b4c77c68f80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to create an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a>  <a href="#a359929efe289961523d8b4c77c68f80d">More...</a><br /></td></tr>
<tr class="separator:a359929efe289961523d8b4c77c68f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f171f68a8b3e6791015fd7470f26d0"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ae5f171f68a8b3e6791015fd7470f26d0">create_or_replace_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ae5f171f68a8b3e6791015fd7470f26d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to create an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a>  <a href="#ae5f171f68a8b3e6791015fd7470f26d0">More...</a><br /></td></tr>
<tr class="separator:ae5f171f68a8b3e6791015fd7470f26d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49be5032bc5e89877bba6755c64a9ff4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a49be5032bc5e89877bba6755c64a9ff4">append_block</a> (concurrency::streams::istream block_data, const utility::string_t &amp;content_md5) const </td></tr>
<tr class="memdesc:a49be5032bc5e89877bba6755c64a9ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits a new block of data to the end of the blob.  <a href="#a49be5032bc5e89877bba6755c64a9ff4">More...</a><br /></td></tr>
<tr class="separator:a49be5032bc5e89877bba6755c64a9ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d200778a2931d86aff6ebd72110a3f2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a1d200778a2931d86aff6ebd72110a3f2">append_block</a> (concurrency::streams::istream block_data, const utility::string_t &amp;content_md5, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a1d200778a2931d86aff6ebd72110a3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits a new block of data to the end of the blob.  <a href="#a1d200778a2931d86aff6ebd72110a3f2">More...</a><br /></td></tr>
<tr class="separator:a1d200778a2931d86aff6ebd72110a3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c9de880a1d8f39f890484f59c4949d"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a65c9de880a1d8f39f890484f59c4949d">append_block_async</a> (concurrency::streams::istream block_data, const utility::string_t &amp;content_md5) const </td></tr>
<tr class="memdesc:a65c9de880a1d8f39f890484f59c4949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to commit a new block of data to the end of the blob.  <a href="#a65c9de880a1d8f39f890484f59c4949d">More...</a><br /></td></tr>
<tr class="separator:a65c9de880a1d8f39f890484f59c4949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19595e2136a254a6b131752254d821af"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a19595e2136a254a6b131752254d821af">append_block_async</a> (concurrency::streams::istream block_data, const utility::string_t &amp;content_md5, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a19595e2136a254a6b131752254d821af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to commit a new block of data to the end of the blob.  <a href="#a19595e2136a254a6b131752254d821af">More...</a><br /></td></tr>
<tr class="separator:a19595e2136a254a6b131752254d821af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebdb8cbf63957dd9559245906bcada9"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a2ebdb8cbf63957dd9559245906bcada9">download_text</a> ()</td></tr>
<tr class="memdesc:a2ebdb8cbf63957dd9559245906bcada9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the blob's contents as a string.  <a href="#a2ebdb8cbf63957dd9559245906bcada9">More...</a><br /></td></tr>
<tr class="separator:a2ebdb8cbf63957dd9559245906bcada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfb3279be89151f0b1d609c28e30dbd"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#afcfb3279be89151f0b1d609c28e30dbd">download_text</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:afcfb3279be89151f0b1d609c28e30dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the blob's contents as a string.  <a href="#afcfb3279be89151f0b1d609c28e30dbd">More...</a><br /></td></tr>
<tr class="separator:afcfb3279be89151f0b1d609c28e30dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed87834aff0d5841f841819e449c01a"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a5ed87834aff0d5841f841819e449c01a">download_text_async</a> ()</td></tr>
<tr class="memdesc:a5ed87834aff0d5841f841819e449c01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the blob's contents as a string.  <a href="#a5ed87834aff0d5841f841819e449c01a">More...</a><br /></td></tr>
<tr class="separator:a5ed87834aff0d5841f841819e449c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04102e7b213540366305128d136bace"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ab04102e7b213540366305128d136bace">download_text_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ab04102e7b213540366305128d136bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the blob's contents as a string.  <a href="#ab04102e7b213540366305128d136bace">More...</a><br /></td></tr>
<tr class="separator:ab04102e7b213540366305128d136bace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b41d0431d3a1f1070d9e8447d2706c4"><td class="memItemLeft" align="right" valign="top">concurrency::streams::ostream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a6b41d0431d3a1f1070d9e8447d2706c4">open_write</a> (bool create_new)</td></tr>
<tr class="memdesc:a6b41d0431d3a1f1070d9e8447d2706c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream for writing to the append blob.  <a href="#a6b41d0431d3a1f1070d9e8447d2706c4">More...</a><br /></td></tr>
<tr class="separator:a6b41d0431d3a1f1070d9e8447d2706c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9efc50cec8f148f92d51bcef84a5e8"><td class="memItemLeft" align="right" valign="top">concurrency::streams::ostream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a1c9efc50cec8f148f92d51bcef84a5e8">open_write</a> (bool create_new, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a1c9efc50cec8f148f92d51bcef84a5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream for writing to the append blob.  <a href="#a1c9efc50cec8f148f92d51bcef84a5e8">More...</a><br /></td></tr>
<tr class="separator:a1c9efc50cec8f148f92d51bcef84a5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8f364d4bdff228ac2fc4a933f8fc54"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; concurrency::streams::ostream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aab8f364d4bdff228ac2fc4a933f8fc54">open_write_async</a> (bool create_new)</td></tr>
<tr class="memdesc:aab8f364d4bdff228ac2fc4a933f8fc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to open a stream for writing to the append blob.  <a href="#aab8f364d4bdff228ac2fc4a933f8fc54">More...</a><br /></td></tr>
<tr class="separator:aab8f364d4bdff228ac2fc4a933f8fc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bceea6c00ec3e6d2665460e8c2bf5"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; concurrency::streams::ostream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a2c3bceea6c00ec3e6d2665460e8c2bf5">open_write_async</a> (bool create_new, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a2c3bceea6c00ec3e6d2665460e8c2bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to open a stream for writing to the append blob.  <a href="#a2c3bceea6c00ec3e6d2665460e8c2bf5">More...</a><br /></td></tr>
<tr class="separator:a2c3bceea6c00ec3e6d2665460e8c2bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9505993bc8d6559a6149bd66f2c740a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a9505993bc8d6559a6149bd66f2c740a1">upload_from_stream</a> (concurrency::streams::istream source)</td></tr>
<tr class="memdesc:a9505993bc8d6559a6149bd66f2c740a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a9505993bc8d6559a6149bd66f2c740a1">More...</a><br /></td></tr>
<tr class="separator:a9505993bc8d6559a6149bd66f2c740a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e102f4fc515419541c45571a424d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a46e102f4fc515419541c45571a424d0a">upload_from_stream</a> (concurrency::streams::istream source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a46e102f4fc515419541c45571a424d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a46e102f4fc515419541c45571a424d0a">More...</a><br /></td></tr>
<tr class="separator:a46e102f4fc515419541c45571a424d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3cd3393d65abeef634a651ea55f752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a7f3cd3393d65abeef634a651ea55f752">upload_from_stream</a> (concurrency::streams::istream source, utility::size64_t length)</td></tr>
<tr class="memdesc:a7f3cd3393d65abeef634a651ea55f752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a7f3cd3393d65abeef634a651ea55f752">More...</a><br /></td></tr>
<tr class="separator:a7f3cd3393d65abeef634a651ea55f752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5355dab1d95ac7c55a74079c675742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aca5355dab1d95ac7c55a74079c675742">upload_from_stream</a> (concurrency::streams::istream source, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aca5355dab1d95ac7c55a74079c675742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten.  <a href="#aca5355dab1d95ac7c55a74079c675742">More...</a><br /></td></tr>
<tr class="separator:aca5355dab1d95ac7c55a74079c675742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20ecfb00b74283a0dcf23d0f542411"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#adb20ecfb00b74283a0dcf23d0f542411">upload_from_stream_async</a> (concurrency::streams::istream source)</td></tr>
<tr class="memdesc:adb20ecfb00b74283a0dcf23d0f542411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#adb20ecfb00b74283a0dcf23d0f542411">More...</a><br /></td></tr>
<tr class="separator:adb20ecfb00b74283a0dcf23d0f542411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6df071e084aaaeb37c76c20331ea4b"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a4f6df071e084aaaeb37c76c20331ea4b">upload_from_stream_async</a> (concurrency::streams::istream source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a4f6df071e084aaaeb37c76c20331ea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a4f6df071e084aaaeb37c76c20331ea4b">More...</a><br /></td></tr>
<tr class="separator:a4f6df071e084aaaeb37c76c20331ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01110f02868596b9c541c0ca02f5e267"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a01110f02868596b9c541c0ca02f5e267">upload_from_stream_async</a> (concurrency::streams::istream source, utility::size64_t length)</td></tr>
<tr class="memdesc:a01110f02868596b9c541c0ca02f5e267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a01110f02868596b9c541c0ca02f5e267">More...</a><br /></td></tr>
<tr class="separator:a01110f02868596b9c541c0ca02f5e267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeef628d4425a78d2a0803e7a03a5088"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aeeef628d4425a78d2a0803e7a03a5088">upload_from_stream_async</a> (concurrency::streams::istream source, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aeeef628d4425a78d2a0803e7a03a5088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#aeeef628d4425a78d2a0803e7a03a5088">More...</a><br /></td></tr>
<tr class="separator:aeeef628d4425a78d2a0803e7a03a5088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d4362965d671d35d4c6822f88b5ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ab8d4362965d671d35d4c6822f88b5ebe">upload_from_file</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:ab8d4362965d671d35d4c6822f88b5ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a file to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#ab8d4362965d671d35d4c6822f88b5ebe">More...</a><br /></td></tr>
<tr class="separator:ab8d4362965d671d35d4c6822f88b5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1beb1978cefba669860e25b11e2638d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ad1beb1978cefba669860e25b11e2638d">upload_from_file</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ad1beb1978cefba669860e25b11e2638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a file to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#ad1beb1978cefba669860e25b11e2638d">More...</a><br /></td></tr>
<tr class="separator:ad1beb1978cefba669860e25b11e2638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bfd277142b64109c37e2f3a1b2f9e8"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a83bfd277142b64109c37e2f3a1b2f9e8">upload_from_file_async</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:a83bfd277142b64109c37e2f3a1b2f9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a file to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a83bfd277142b64109c37e2f3a1b2f9e8">More...</a><br /></td></tr>
<tr class="separator:a83bfd277142b64109c37e2f3a1b2f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa68bb751ccfb6d1a265e2b388d8085"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a6fa68bb751ccfb6d1a265e2b388d8085">upload_from_file_async</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a6fa68bb751ccfb6d1a265e2b388d8085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to upload a file to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a6fa68bb751ccfb6d1a265e2b388d8085">More...</a><br /></td></tr>
<tr class="separator:a6fa68bb751ccfb6d1a265e2b388d8085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b336d1a7093428b784b1fb381788e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a1b336d1a7093428b784b1fb381788e12">upload_text</a> (const utility::string_t &amp;content)</td></tr>
<tr class="memdesc:a1b336d1a7093428b784b1fb381788e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a1b336d1a7093428b784b1fb381788e12">More...</a><br /></td></tr>
<tr class="separator:a1b336d1a7093428b784b1fb381788e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db5f84da3a32b866cd4ec5662df067e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a3db5f84da3a32b866cd4ec5662df067e">upload_text</a> (const utility::string_t &amp;content, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a3db5f84da3a32b866cd4ec5662df067e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a3db5f84da3a32b866cd4ec5662df067e">More...</a><br /></td></tr>
<tr class="separator:a3db5f84da3a32b866cd4ec5662df067e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64961de61d2b3ed8478b847ce9ca217"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#ac64961de61d2b3ed8478b847ce9ca217">upload_text_async</a> (const utility::string_t &amp;content)</td></tr>
<tr class="memdesc:ac64961de61d2b3ed8478b847ce9ca217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#ac64961de61d2b3ed8478b847ce9ca217">More...</a><br /></td></tr>
<tr class="separator:ac64961de61d2b3ed8478b847ce9ca217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c94abec395af89096048ed11543c069"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a0c94abec395af89096048ed11543c069">upload_text_async</a> (const utility::string_t &amp;content, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a0c94abec395af89096048ed11543c069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten.  <a href="#a0c94abec395af89096048ed11543c069">More...</a><br /></td></tr>
<tr class="separator:a0c94abec395af89096048ed11543c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69ec049af3605909d1022c95c70dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a7f69ec049af3605909d1022c95c70dfa">append_from_stream</a> (concurrency::streams::istream source)</td></tr>
<tr class="memdesc:a7f69ec049af3605909d1022c95c70dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a7f69ec049af3605909d1022c95c70dfa">More...</a><br /></td></tr>
<tr class="separator:a7f69ec049af3605909d1022c95c70dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec568217a8fbcb306a1a77e266a627a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#abec568217a8fbcb306a1a77e266a627a">append_from_stream</a> (concurrency::streams::istream source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:abec568217a8fbcb306a1a77e266a627a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#abec568217a8fbcb306a1a77e266a627a">More...</a><br /></td></tr>
<tr class="separator:abec568217a8fbcb306a1a77e266a627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c92060a87b7cceb68c917feb9dd96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a45c92060a87b7cceb68c917feb9dd96a">append_from_stream</a> (concurrency::streams::istream source, utility::size64_t length)</td></tr>
<tr class="memdesc:a45c92060a87b7cceb68c917feb9dd96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a45c92060a87b7cceb68c917feb9dd96a">More...</a><br /></td></tr>
<tr class="separator:a45c92060a87b7cceb68c917feb9dd96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac0123c73a8a41e70b789c16fa84e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aaac0123c73a8a41e70b789c16fa84e2d">append_from_stream</a> (concurrency::streams::istream source, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aaac0123c73a8a41e70b789c16fa84e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#aaac0123c73a8a41e70b789c16fa84e2d">More...</a><br /></td></tr>
<tr class="separator:aaac0123c73a8a41e70b789c16fa84e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ecdc93d293d8cca8c816b4c8cdf818"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aa7ecdc93d293d8cca8c816b4c8cdf818">append_from_stream_async</a> (concurrency::streams::istream source)</td></tr>
<tr class="memdesc:aa7ecdc93d293d8cca8c816b4c8cdf818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#aa7ecdc93d293d8cca8c816b4c8cdf818">More...</a><br /></td></tr>
<tr class="separator:aa7ecdc93d293d8cca8c816b4c8cdf818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43382935d83ba8d62e45dc4e93986b20"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a43382935d83ba8d62e45dc4e93986b20">append_from_stream_async</a> (concurrency::streams::istream source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a43382935d83ba8d62e45dc4e93986b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a43382935d83ba8d62e45dc4e93986b20">More...</a><br /></td></tr>
<tr class="separator:a43382935d83ba8d62e45dc4e93986b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe9afce0f8c5e5116729db10d74703a"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#acfe9afce0f8c5e5116729db10d74703a">append_from_stream_async</a> (concurrency::streams::istream source, utility::size64_t length)</td></tr>
<tr class="memdesc:acfe9afce0f8c5e5116729db10d74703a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#acfe9afce0f8c5e5116729db10d74703a">More...</a><br /></td></tr>
<tr class="separator:acfe9afce0f8c5e5116729db10d74703a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbc6364c5ba9d3f41f545b5a5442f11"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a8cbc6364c5ba9d3f41f545b5a5442f11">append_from_stream_async</a> (concurrency::streams::istream source, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a8cbc6364c5ba9d3f41f545b5a5442f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a8cbc6364c5ba9d3f41f545b5a5442f11">More...</a><br /></td></tr>
<tr class="separator:a8cbc6364c5ba9d3f41f545b5a5442f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a9a7fb0d6ba66d25e52dd7a417ea83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a58a9a7fb0d6ba66d25e52dd7a417ea83">append_from_file</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:a58a9a7fb0d6ba66d25e52dd7a417ea83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a58a9a7fb0d6ba66d25e52dd7a417ea83">More...</a><br /></td></tr>
<tr class="separator:a58a9a7fb0d6ba66d25e52dd7a417ea83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5054e49a4a635cc72e4b3159e7a5c1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a5054e49a4a635cc72e4b3159e7a5c1aa">append_from_file</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a5054e49a4a635cc72e4b3159e7a5c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a5054e49a4a635cc72e4b3159e7a5c1aa">More...</a><br /></td></tr>
<tr class="separator:a5054e49a4a635cc72e4b3159e7a5c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83576fa3701a19a6dcdc29ee56f0b178"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a83576fa3701a19a6dcdc29ee56f0b178">append_from_file_async</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:a83576fa3701a19a6dcdc29ee56f0b178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a83576fa3701a19a6dcdc29ee56f0b178">More...</a><br /></td></tr>
<tr class="separator:a83576fa3701a19a6dcdc29ee56f0b178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5515d772566e9ce8f77189c4d9534b5a"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a5515d772566e9ce8f77189c4d9534b5a">append_from_file_async</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a5515d772566e9ce8f77189c4d9534b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a5515d772566e9ce8f77189c4d9534b5a">More...</a><br /></td></tr>
<tr class="separator:a5515d772566e9ce8f77189c4d9534b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9086d6dbe7040fe936d1822d72d6aa45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a9086d6dbe7040fe936d1822d72d6aa45">append_text</a> (const utility::string_t &amp;content)</td></tr>
<tr class="memdesc:a9086d6dbe7040fe936d1822d72d6aa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a9086d6dbe7040fe936d1822d72d6aa45">More...</a><br /></td></tr>
<tr class="separator:a9086d6dbe7040fe936d1822d72d6aa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e12358fa5240ec671ebcca5955e082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#aa6e12358fa5240ec671ebcca5955e082">append_text</a> (const utility::string_t &amp;content, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aa6e12358fa5240ec671ebcca5955e082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#aa6e12358fa5240ec671ebcca5955e082">More...</a><br /></td></tr>
<tr class="separator:aa6e12358fa5240ec671ebcca5955e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35445bc882a0fa3eefffe7b05f59692b"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a35445bc882a0fa3eefffe7b05f59692b">append_text_async</a> (const utility::string_t &amp;content)</td></tr>
<tr class="memdesc:a35445bc882a0fa3eefffe7b05f59692b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a35445bc882a0fa3eefffe7b05f59692b">More...</a><br /></td></tr>
<tr class="separator:a35445bc882a0fa3eefffe7b05f59692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e86891294050a41c03ba6cb1b137f9"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html#a17e86891294050a41c03ba6cb1b137f9">append_text_async</a> (const utility::string_t &amp;content, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a17e86891294050a41c03ba6cb1b137f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous operation to append a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario.  <a href="#a17e86891294050a41c03ba6cb1b137f9">More...</a><br /></td></tr>
<tr class="separator:a17e86891294050a41c03ba6cb1b137f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classazure_1_1storage_1_1cloud__blob"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classazure_1_1storage_1_1cloud__blob')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">azure::storage::cloud_blob</a></td></tr>
<tr class="memitem:aa93b7f65c75ee69032a12c5deed609a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aa93b7f65c75ee69032a12c5deed609a1">cloud_blob</a> ()</td></tr>
<tr class="memdesc:aa93b7f65c75ee69032a12c5deed609a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_...">azure::storage::cloud_blob</a> class.  <a href="#aa93b7f65c75ee69032a12c5deed609a1">More...</a><br /></td></tr>
<tr class="separator:aa93b7f65c75ee69032a12c5deed609a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f52cce9cc3c4cbf0edf57f9df137c1b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0f52cce9cc3c4cbf0edf57f9df137c1b">cloud_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>)</td></tr>
<tr class="memdesc:a0f52cce9cc3c4cbf0edf57f9df137c1b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_...">azure::storage::cloud_blob</a> class using an absolute URI to the blob.  <a href="#a0f52cce9cc3c4cbf0edf57f9df137c1b">More...</a><br /></td></tr>
<tr class="separator:a0f52cce9cc3c4cbf0edf57f9df137c1b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e4ec0a3ecf8b6447d8d1cd3a19fd77 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a86e4ec0a3ecf8b6447d8d1cd3a19fd77">cloud_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>, <a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a> credentials)</td></tr>
<tr class="memdesc:a86e4ec0a3ecf8b6447d8d1cd3a19fd77 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_...">azure::storage::cloud_blob</a> class using an absolute URI to the blob.  <a href="#a86e4ec0a3ecf8b6447d8d1cd3a19fd77">More...</a><br /></td></tr>
<tr class="separator:a86e4ec0a3ecf8b6447d8d1cd3a19fd77 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef52f4053183d2d1965760fb215c2296 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aef52f4053183d2d1965760fb215c2296">cloud_blob</a> (<a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a>, utility::string_t <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a68c895693f527a1148fa6abc8672c626">snapshot_time</a>, <a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a> credentials)</td></tr>
<tr class="memdesc:aef52f4053183d2d1965760fb215c2296 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_...">azure::storage::cloud_blob</a> class using an absolute URI to the blob.  <a href="#aef52f4053183d2d1965760fb215c2296">More...</a><br /></td></tr>
<tr class="separator:aef52f4053183d2d1965760fb215c2296 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3805a2462659ba1397f3074cad5c44 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API <a class="el" href="classazure_1_1storage_1_1cloud__blob__directory.html">cloud_blob_directory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#abe3805a2462659ba1397f3074cad5c44">get_parent_reference</a> () const </td></tr>
<tr class="memdesc:abe3805a2462659ba1397f3074cad5c44 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classazure_1_1storage_1_1cloud__blob__directory.html" title="Represents a virtual directory of blobs, designated by a delimiter character. ">azure::storage::cloud_blob_directory</a> object representing the virtual parent directory for the blob.  <a href="#abe3805a2462659ba1397f3074cad5c44">More...</a><br /></td></tr>
<tr class="separator:abe3805a2462659ba1397f3074cad5c44 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae010a11751caedad9bf91b6b24d1668a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API <a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae010a11751caedad9bf91b6b24d1668a">snapshot_qualified_uri</a> () const </td></tr>
<tr class="memdesc:ae010a11751caedad9bf91b6b24d1668a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the snapshot-qualified URI to the blob.  <a href="#ae010a11751caedad9bf91b6b24d1668a">More...</a><br /></td></tr>
<tr class="separator:ae010a11751caedad9bf91b6b24d1668a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe939d5c92112c71c17ab65713cd2d64 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#abe939d5c92112c71c17ab65713cd2d64">get_shared_access_signature</a> (const <a class="el" href="classazure_1_1storage_1_1blob__shared__access__policy.html">blob_shared_access_policy</a> &amp;policy) const </td></tr>
<tr class="memdesc:abe939d5c92112c71c17ab65713cd2d64 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared access signature for the blob.  <a href="#abe939d5c92112c71c17ab65713cd2d64">More...</a><br /></td></tr>
<tr class="separator:abe939d5c92112c71c17ab65713cd2d64 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cad754664d2b9f160eab4c435d3c5c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1cad754664d2b9f160eab4c435d3c5c7">get_shared_access_signature</a> (const <a class="el" href="classazure_1_1storage_1_1blob__shared__access__policy.html">blob_shared_access_policy</a> &amp;policy, const utility::string_t &amp;stored_policy_identifier) const </td></tr>
<tr class="memdesc:a1cad754664d2b9f160eab4c435d3c5c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared access signature for the blob.  <a href="#a1cad754664d2b9f160eab4c435d3c5c7">More...</a><br /></td></tr>
<tr class="separator:a1cad754664d2b9f160eab4c435d3c5c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfec5db76925256ec4e7d903ae92adb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a2cfec5db76925256ec4e7d903ae92adb">get_shared_access_signature</a> (const <a class="el" href="classazure_1_1storage_1_1blob__shared__access__policy.html">blob_shared_access_policy</a> &amp;policy, const utility::string_t &amp;stored_policy_identifier, const <a class="el" href="classazure_1_1storage_1_1cloud__blob__shared__access__headers.html">cloud_blob_shared_access_headers</a> &amp;headers) const </td></tr>
<tr class="memdesc:a2cfec5db76925256ec4e7d903ae92adb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared access signature for the blob.  <a href="#a2cfec5db76925256ec4e7d903ae92adb">More...</a><br /></td></tr>
<tr class="separator:a2cfec5db76925256ec4e7d903ae92adb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb57ea0a3f1ecb1f1ce4720bf05fc7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a77bb57ea0a3f1ecb1f1ce4720bf05fc7">open_read</a> ()</td></tr>
<tr class="memdesc:a77bb57ea0a3f1ecb1f1ce4720bf05fc7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream for reading from the blob.  <a href="#a77bb57ea0a3f1ecb1f1ce4720bf05fc7">More...</a><br /></td></tr>
<tr class="separator:a77bb57ea0a3f1ecb1f1ce4720bf05fc7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00f54ab9bfa65e0bc962fb0822dd949 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ad00f54ab9bfa65e0bc962fb0822dd949">open_read</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ad00f54ab9bfa65e0bc962fb0822dd949 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream for reading from the blob.  <a href="#ad00f54ab9bfa65e0bc962fb0822dd949">More...</a><br /></td></tr>
<tr class="separator:ad00f54ab9bfa65e0bc962fb0822dd949 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca69db5b427751768d186cc4c920f91e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; concurrency::streams::istream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aca69db5b427751768d186cc4c920f91e">open_read_async</a> ()</td></tr>
<tr class="memdesc:aca69db5b427751768d186cc4c920f91e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to open a stream for reading from the blob.  <a href="#aca69db5b427751768d186cc4c920f91e">More...</a><br /></td></tr>
<tr class="separator:aca69db5b427751768d186cc4c920f91e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe58eb7f0452c4d393ac79ea2defaa6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; concurrency::streams::istream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#afbe58eb7f0452c4d393ac79ea2defaa6">open_read_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:afbe58eb7f0452c4d393ac79ea2defaa6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to open a stream for reading from the blob.  <a href="#afbe58eb7f0452c4d393ac79ea2defaa6">More...</a><br /></td></tr>
<tr class="separator:afbe58eb7f0452c4d393ac79ea2defaa6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2d98090a2052baafa3a5dc33bb1d06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1c2d98090a2052baafa3a5dc33bb1d06">exists</a> ()</td></tr>
<tr class="memdesc:a1c2d98090a2052baafa3a5dc33bb1d06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks existence of the blob.  <a href="#a1c2d98090a2052baafa3a5dc33bb1d06">More...</a><br /></td></tr>
<tr class="separator:a1c2d98090a2052baafa3a5dc33bb1d06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff699a1e2d1b974f9c84d3ca4970b03 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0ff699a1e2d1b974f9c84d3ca4970b03">exists</a> (const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a0ff699a1e2d1b974f9c84d3ca4970b03 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks existence of the blob.  <a href="#a0ff699a1e2d1b974f9c84d3ca4970b03">More...</a><br /></td></tr>
<tr class="separator:a0ff699a1e2d1b974f9c84d3ca4970b03 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409723d775cb216500141eaf8f1efd83 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a409723d775cb216500141eaf8f1efd83">exists_async</a> ()</td></tr>
<tr class="memdesc:a409723d775cb216500141eaf8f1efd83 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to check the existence of the blob.  <a href="#a409723d775cb216500141eaf8f1efd83">More...</a><br /></td></tr>
<tr class="separator:a409723d775cb216500141eaf8f1efd83 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74e8837e7563c088b054c67422d6751 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af74e8837e7563c088b054c67422d6751">exists_async</a> (const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:af74e8837e7563c088b054c67422d6751 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to check the existence of the blob.  <a href="#af74e8837e7563c088b054c67422d6751">More...</a><br /></td></tr>
<tr class="separator:af74e8837e7563c088b054c67422d6751 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd80797166e4b0ff11b4d9f432ac828f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#afd80797166e4b0ff11b4d9f432ac828f">download_attributes</a> ()</td></tr>
<tr class="memdesc:afd80797166e4b0ff11b4d9f432ac828f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a blob's properties and metadata.  <a href="#afd80797166e4b0ff11b4d9f432ac828f">More...</a><br /></td></tr>
<tr class="separator:afd80797166e4b0ff11b4d9f432ac828f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d22f029d303e166765e8d4589d6d28 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a86d22f029d303e166765e8d4589d6d28">download_attributes</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a86d22f029d303e166765e8d4589d6d28 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a blob's properties and metadata.  <a href="#a86d22f029d303e166765e8d4589d6d28">More...</a><br /></td></tr>
<tr class="separator:a86d22f029d303e166765e8d4589d6d28 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10eeb4b154a0ce83ea875434eb41bf2 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aa10eeb4b154a0ce83ea875434eb41bf2">download_attributes_async</a> ()</td></tr>
<tr class="memdesc:aa10eeb4b154a0ce83ea875434eb41bf2 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to populate a blob's properties and metadata.  <a href="#aa10eeb4b154a0ce83ea875434eb41bf2">More...</a><br /></td></tr>
<tr class="separator:aa10eeb4b154a0ce83ea875434eb41bf2 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991b05d7dc64f08d37e932b49f6f19b6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a991b05d7dc64f08d37e932b49f6f19b6">download_attributes_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a991b05d7dc64f08d37e932b49f6f19b6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to populate a blob's properties and metadata.  <a href="#a991b05d7dc64f08d37e932b49f6f19b6">More...</a><br /></td></tr>
<tr class="separator:a991b05d7dc64f08d37e932b49f6f19b6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1a600111536334a7ebe191a4253b15 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1b1a600111536334a7ebe191a4253b15">upload_metadata</a> ()</td></tr>
<tr class="memdesc:a1b1a600111536334a7ebe191a4253b15 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the blob's metadata.  <a href="#a1b1a600111536334a7ebe191a4253b15">More...</a><br /></td></tr>
<tr class="separator:a1b1a600111536334a7ebe191a4253b15 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812bcecb0fef1b46111ed8c69c46226 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ac812bcecb0fef1b46111ed8c69c46226">upload_metadata</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ac812bcecb0fef1b46111ed8c69c46226 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the blob's metadata.  <a href="#ac812bcecb0fef1b46111ed8c69c46226">More...</a><br /></td></tr>
<tr class="separator:ac812bcecb0fef1b46111ed8c69c46226 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4f360b748085808327a09096d374d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a18d4f360b748085808327a09096d374d">upload_metadata_async</a> ()</td></tr>
<tr class="memdesc:a18d4f360b748085808327a09096d374d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to update the blob's metadata.  <a href="#a18d4f360b748085808327a09096d374d">More...</a><br /></td></tr>
<tr class="separator:a18d4f360b748085808327a09096d374d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3fc00247ba83eee41b7f4679c2e58a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0e3fc00247ba83eee41b7f4679c2e58a">upload_metadata_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a0e3fc00247ba83eee41b7f4679c2e58a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to update the blob's metadata.  <a href="#a0e3fc00247ba83eee41b7f4679c2e58a">More...</a><br /></td></tr>
<tr class="separator:a0e3fc00247ba83eee41b7f4679c2e58a inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c02d1c4c2db191c72bcbb8895ff2aad inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a9c02d1c4c2db191c72bcbb8895ff2aad">upload_properties</a> ()</td></tr>
<tr class="memdesc:a9c02d1c4c2db191c72bcbb8895ff2aad inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the blob's properties.  <a href="#a9c02d1c4c2db191c72bcbb8895ff2aad">More...</a><br /></td></tr>
<tr class="separator:a9c02d1c4c2db191c72bcbb8895ff2aad inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16faada481dc1838dc05a389e269f754 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a16faada481dc1838dc05a389e269f754">upload_properties</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a16faada481dc1838dc05a389e269f754 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the blob's properties.  <a href="#a16faada481dc1838dc05a389e269f754">More...</a><br /></td></tr>
<tr class="separator:a16faada481dc1838dc05a389e269f754 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a085763cb087dd0af2e9dbcc9dec412 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a4a085763cb087dd0af2e9dbcc9dec412">upload_properties_async</a> ()</td></tr>
<tr class="memdesc:a4a085763cb087dd0af2e9dbcc9dec412 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to update the blob's properties.  <a href="#a4a085763cb087dd0af2e9dbcc9dec412">More...</a><br /></td></tr>
<tr class="separator:a4a085763cb087dd0af2e9dbcc9dec412 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6801e09d2a6f92ab48a980161b66f8 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aca6801e09d2a6f92ab48a980161b66f8">upload_properties_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aca6801e09d2a6f92ab48a980161b66f8 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to update the blob's properties.  <a href="#aca6801e09d2a6f92ab48a980161b66f8">More...</a><br /></td></tr>
<tr class="separator:aca6801e09d2a6f92ab48a980161b66f8 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc1c28d3c37ed1856239d4f7587813d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a3fc1c28d3c37ed1856239d4f7587813d">delete_blob</a> ()</td></tr>
<tr class="memdesc:a3fc1c28d3c37ed1856239d4f7587813d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the blob.  <a href="#a3fc1c28d3c37ed1856239d4f7587813d">More...</a><br /></td></tr>
<tr class="separator:a3fc1c28d3c37ed1856239d4f7587813d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fd632b1d146be5d2ecc0b83ac35a8e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae9fd632b1d146be5d2ecc0b83ac35a8e">delete_blob</a> (delete_snapshots_option snapshots_option, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:ae9fd632b1d146be5d2ecc0b83ac35a8e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the blob.  <a href="#ae9fd632b1d146be5d2ecc0b83ac35a8e">More...</a><br /></td></tr>
<tr class="separator:ae9fd632b1d146be5d2ecc0b83ac35a8e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf45da22ff1f50342e5ebfd6fc43a1c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#acf45da22ff1f50342e5ebfd6fc43a1c1">delete_blob_async</a> ()</td></tr>
<tr class="memdesc:acf45da22ff1f50342e5ebfd6fc43a1c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to delete the blob.  <a href="#acf45da22ff1f50342e5ebfd6fc43a1c1">More...</a><br /></td></tr>
<tr class="separator:acf45da22ff1f50342e5ebfd6fc43a1c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37953444993f5957bca417491922f5c inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aa37953444993f5957bca417491922f5c">delete_blob_async</a> (delete_snapshots_option snapshots_option, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aa37953444993f5957bca417491922f5c inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to delete the blob.  <a href="#aa37953444993f5957bca417491922f5c">More...</a><br /></td></tr>
<tr class="separator:aa37953444993f5957bca417491922f5c inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbf060a55c8b8cbac0040aaa96938e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a51cbf060a55c8b8cbac0040aaa96938e">delete_blob_if_exists</a> ()</td></tr>
<tr class="memdesc:a51cbf060a55c8b8cbac0040aaa96938e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the blob if it already exists.  <a href="#a51cbf060a55c8b8cbac0040aaa96938e">More...</a><br /></td></tr>
<tr class="separator:a51cbf060a55c8b8cbac0040aaa96938e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8460cfb70eba63f3c78a5a37bcc5a306 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a8460cfb70eba63f3c78a5a37bcc5a306">delete_blob_if_exists</a> (delete_snapshots_option snapshots_option, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a8460cfb70eba63f3c78a5a37bcc5a306 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the blob if it already exists.  <a href="#a8460cfb70eba63f3c78a5a37bcc5a306">More...</a><br /></td></tr>
<tr class="separator:a8460cfb70eba63f3c78a5a37bcc5a306 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b00cbe08adec5ef5ac245d737ef9ba inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a99b00cbe08adec5ef5ac245d737ef9ba">delete_blob_if_exists_async</a> ()</td></tr>
<tr class="memdesc:a99b00cbe08adec5ef5ac245d737ef9ba inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to delete the blob if it already exists.  <a href="#a99b00cbe08adec5ef5ac245d737ef9ba">More...</a><br /></td></tr>
<tr class="separator:a99b00cbe08adec5ef5ac245d737ef9ba inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5f65eb780a689471056708fd233a53 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1c5f65eb780a689471056708fd233a53">delete_blob_if_exists_async</a> (delete_snapshots_option snapshots_option, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a1c5f65eb780a689471056708fd233a53 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to delete the blob if it already exists.  <a href="#a1c5f65eb780a689471056708fd233a53">More...</a><br /></td></tr>
<tr class="separator:a1c5f65eb780a689471056708fd233a53 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13280e298fbf7b8b6000702e1b56034e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a13280e298fbf7b8b6000702e1b56034e">acquire_lease</a> (const <a class="el" href="classazure_1_1storage_1_1lease__time.html">azure::storage::lease_time</a> &amp;duration, const utility::string_t &amp;proposed_lease_id) const </td></tr>
<tr class="memdesc:a13280e298fbf7b8b6000702e1b56034e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a lease on the blob.  <a href="#a13280e298fbf7b8b6000702e1b56034e">More...</a><br /></td></tr>
<tr class="separator:a13280e298fbf7b8b6000702e1b56034e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1909a575d5ae3f4a2729b6a5ba6806dc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1909a575d5ae3f4a2729b6a5ba6806dc">acquire_lease</a> (const <a class="el" href="classazure_1_1storage_1_1lease__time.html">azure::storage::lease_time</a> &amp;duration, const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a1909a575d5ae3f4a2729b6a5ba6806dc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a lease on the blob.  <a href="#a1909a575d5ae3f4a2729b6a5ba6806dc">More...</a><br /></td></tr>
<tr class="separator:a1909a575d5ae3f4a2729b6a5ba6806dc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860cb8d9a24ece6a0e1bd22caffbe18 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0860cb8d9a24ece6a0e1bd22caffbe18">acquire_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1lease__time.html">azure::storage::lease_time</a> &amp;duration, const utility::string_t &amp;proposed_lease_id) const </td></tr>
<tr class="memdesc:a0860cb8d9a24ece6a0e1bd22caffbe18 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to acquire a lease on the blob.  <a href="#a0860cb8d9a24ece6a0e1bd22caffbe18">More...</a><br /></td></tr>
<tr class="separator:a0860cb8d9a24ece6a0e1bd22caffbe18 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99353727db26b71b8c6b82b4dd83cceb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a99353727db26b71b8c6b82b4dd83cceb">acquire_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1lease__time.html">azure::storage::lease_time</a> &amp;duration, const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a99353727db26b71b8c6b82b4dd83cceb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to acquire a lease on the blob.  <a href="#a99353727db26b71b8c6b82b4dd83cceb">More...</a><br /></td></tr>
<tr class="separator:a99353727db26b71b8c6b82b4dd83cceb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75df346dd6e2dff653c2eb67e4f2886 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af75df346dd6e2dff653c2eb67e4f2886">renew_lease</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:af75df346dd6e2dff653c2eb67e4f2886 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renews a lease on the blob.  <a href="#af75df346dd6e2dff653c2eb67e4f2886">More...</a><br /></td></tr>
<tr class="separator:af75df346dd6e2dff653c2eb67e4f2886 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f2f5ffd4181782d4647b5b56fde225 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a15f2f5ffd4181782d4647b5b56fde225">renew_lease</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a15f2f5ffd4181782d4647b5b56fde225 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renews a lease on the blob.  <a href="#a15f2f5ffd4181782d4647b5b56fde225">More...</a><br /></td></tr>
<tr class="separator:a15f2f5ffd4181782d4647b5b56fde225 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886170472a188aeb7660340557d2bb5e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a886170472a188aeb7660340557d2bb5e">renew_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:a886170472a188aeb7660340557d2bb5e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to renew a lease on the blob.  <a href="#a886170472a188aeb7660340557d2bb5e">More...</a><br /></td></tr>
<tr class="separator:a886170472a188aeb7660340557d2bb5e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18c8df5ca6174fb5b6c6d27ebee841 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a3b18c8df5ca6174fb5b6c6d27ebee841">renew_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a3b18c8df5ca6174fb5b6c6d27ebee841 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to renew a lease on the blob.  <a href="#a3b18c8df5ca6174fb5b6c6d27ebee841">More...</a><br /></td></tr>
<tr class="separator:a3b18c8df5ca6174fb5b6c6d27ebee841 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d9d4bd113ef372562b9916317e48d0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae2d9d4bd113ef372562b9916317e48d0">change_lease</a> (const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:ae2d9d4bd113ef372562b9916317e48d0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the lease ID on the blob.  <a href="#ae2d9d4bd113ef372562b9916317e48d0">More...</a><br /></td></tr>
<tr class="separator:ae2d9d4bd113ef372562b9916317e48d0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69643a82b239fe33b059269290da659 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae69643a82b239fe33b059269290da659">change_lease</a> (const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:ae69643a82b239fe33b059269290da659 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the lease ID on the blob.  <a href="#ae69643a82b239fe33b059269290da659">More...</a><br /></td></tr>
<tr class="separator:ae69643a82b239fe33b059269290da659 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3394f6c5c9ff15595e833b504954e3e1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a3394f6c5c9ff15595e833b504954e3e1">change_lease_async</a> (const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:a3394f6c5c9ff15595e833b504954e3e1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to change the lease ID on the blob.  <a href="#a3394f6c5c9ff15595e833b504954e3e1">More...</a><br /></td></tr>
<tr class="separator:a3394f6c5c9ff15595e833b504954e3e1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dbc08a5bbcb91d156f8cc01be8cf31 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a06dbc08a5bbcb91d156f8cc01be8cf31">change_lease_async</a> (const utility::string_t &amp;proposed_lease_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a06dbc08a5bbcb91d156f8cc01be8cf31 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to change the lease ID on the blob.  <a href="#a06dbc08a5bbcb91d156f8cc01be8cf31">More...</a><br /></td></tr>
<tr class="separator:a06dbc08a5bbcb91d156f8cc01be8cf31 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fc2db304081b5f9b7d05cfb0cd25b7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a30fc2db304081b5f9b7d05cfb0cd25b7">release_lease</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:a30fc2db304081b5f9b7d05cfb0cd25b7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lease on the blob.  <a href="#a30fc2db304081b5f9b7d05cfb0cd25b7">More...</a><br /></td></tr>
<tr class="separator:a30fc2db304081b5f9b7d05cfb0cd25b7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6417e11c3f88848f56b52bbac7d56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a2af6417e11c3f88848f56b52bbac7d56">release_lease</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a2af6417e11c3f88848f56b52bbac7d56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lease on the blob.  <a href="#a2af6417e11c3f88848f56b52bbac7d56">More...</a><br /></td></tr>
<tr class="separator:a2af6417e11c3f88848f56b52bbac7d56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01799e93e094b07e34f88190a2be5d7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ac01799e93e094b07e34f88190a2be5d7">release_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition) const </td></tr>
<tr class="memdesc:ac01799e93e094b07e34f88190a2be5d7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to release the lease on the blob.  <a href="#ac01799e93e094b07e34f88190a2be5d7">More...</a><br /></td></tr>
<tr class="separator:ac01799e93e094b07e34f88190a2be5d7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0626826df33708be136ece129842a72 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ad0626826df33708be136ece129842a72">release_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:ad0626826df33708be136ece129842a72 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to release the lease on the blob.  <a href="#ad0626826df33708be136ece129842a72">More...</a><br /></td></tr>
<tr class="separator:ad0626826df33708be136ece129842a72 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cc5a75093cc12263e82fd208eef678 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">std::chrono::seconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a49cc5a75093cc12263e82fd208eef678">break_lease</a> (const <a class="el" href="classazure_1_1storage_1_1lease__break__period.html">azure::storage::lease_break_period</a> &amp;break_period) const </td></tr>
<tr class="memdesc:a49cc5a75093cc12263e82fd208eef678 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the current lease on the blob.  <a href="#a49cc5a75093cc12263e82fd208eef678">More...</a><br /></td></tr>
<tr class="separator:a49cc5a75093cc12263e82fd208eef678 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ab5b2b83925b7960c137e3d26eb052 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">std::chrono::seconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a57ab5b2b83925b7960c137e3d26eb052">break_lease</a> (const <a class="el" href="classazure_1_1storage_1_1lease__break__period.html">azure::storage::lease_break_period</a> &amp;break_period, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a57ab5b2b83925b7960c137e3d26eb052 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the current lease on the blob.  <a href="#a57ab5b2b83925b7960c137e3d26eb052">More...</a><br /></td></tr>
<tr class="separator:a57ab5b2b83925b7960c137e3d26eb052 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f549dcec97c8e0c2925a5afa484f36 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; std::chrono::seconds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a08f549dcec97c8e0c2925a5afa484f36">break_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1lease__break__period.html">azure::storage::lease_break_period</a> &amp;break_period) const </td></tr>
<tr class="memdesc:a08f549dcec97c8e0c2925a5afa484f36 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to break the current lease on the blob.  <a href="#a08f549dcec97c8e0c2925a5afa484f36">More...</a><br /></td></tr>
<tr class="separator:a08f549dcec97c8e0c2925a5afa484f36 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e3140cb82e6def8fbe9f3a3849afa5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; std::chrono::seconds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a73e3140cb82e6def8fbe9f3a3849afa5">break_lease_async</a> (const <a class="el" href="classazure_1_1storage_1_1lease__break__period.html">azure::storage::lease_break_period</a> &amp;break_period, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:a73e3140cb82e6def8fbe9f3a3849afa5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to break the current lease on the blob.  <a href="#a73e3140cb82e6def8fbe9f3a3849afa5">More...</a><br /></td></tr>
<tr class="separator:a73e3140cb82e6def8fbe9f3a3849afa5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97825ae3ab85960a36abd898af1b64a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a97825ae3ab85960a36abd898af1b64a1">download_to_stream</a> (concurrency::streams::ostream target)</td></tr>
<tr class="memdesc:a97825ae3ab85960a36abd898af1b64a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the contents of a blob to a stream.  <a href="#a97825ae3ab85960a36abd898af1b64a1">More...</a><br /></td></tr>
<tr class="separator:a97825ae3ab85960a36abd898af1b64a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4636189abfa935e6772ea43a706150 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a8e4636189abfa935e6772ea43a706150">download_to_stream</a> (concurrency::streams::ostream target, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a8e4636189abfa935e6772ea43a706150 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the contents of a blob to a stream.  <a href="#a8e4636189abfa935e6772ea43a706150">More...</a><br /></td></tr>
<tr class="separator:a8e4636189abfa935e6772ea43a706150 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bacc46023ce653e40467757dc358697 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a9bacc46023ce653e40467757dc358697">download_to_stream_async</a> (concurrency::streams::ostream target)</td></tr>
<tr class="memdesc:a9bacc46023ce653e40467757dc358697 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the contents of a blob to a stream.  <a href="#a9bacc46023ce653e40467757dc358697">More...</a><br /></td></tr>
<tr class="separator:a9bacc46023ce653e40467757dc358697 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb472db5399d2efaaad7fcae147013c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#acb472db5399d2efaaad7fcae147013c7">download_to_stream_async</a> (concurrency::streams::ostream target, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:acb472db5399d2efaaad7fcae147013c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the contents of a blob to a stream.  <a href="#acb472db5399d2efaaad7fcae147013c7">More...</a><br /></td></tr>
<tr class="separator:acb472db5399d2efaaad7fcae147013c7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffc8868e26ffb15422a51fa6c74e02b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a9ffc8868e26ffb15422a51fa6c74e02b">download_range_to_stream</a> (concurrency::streams::ostream target, utility::size64_t offset, utility::size64_t length)</td></tr>
<tr class="memdesc:a9ffc8868e26ffb15422a51fa6c74e02b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads a range of bytes in a blob to a stream.  <a href="#a9ffc8868e26ffb15422a51fa6c74e02b">More...</a><br /></td></tr>
<tr class="separator:a9ffc8868e26ffb15422a51fa6c74e02b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244ca53ce274bda36550bce44e2547ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a244ca53ce274bda36550bce44e2547ec">download_range_to_stream</a> (concurrency::streams::ostream target, utility::size64_t offset, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a244ca53ce274bda36550bce44e2547ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads a range of bytes in a blob to a stream.  <a href="#a244ca53ce274bda36550bce44e2547ec">More...</a><br /></td></tr>
<tr class="separator:a244ca53ce274bda36550bce44e2547ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f0e1512a16e1c5706bf523c0b63b57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a61f0e1512a16e1c5706bf523c0b63b57">download_range_to_stream_async</a> (concurrency::streams::ostream target, int64_t offset, int64_t length)</td></tr>
<tr class="memdesc:a61f0e1512a16e1c5706bf523c0b63b57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download a range of bytes in a blob to a stream.  <a href="#a61f0e1512a16e1c5706bf523c0b63b57">More...</a><br /></td></tr>
<tr class="separator:a61f0e1512a16e1c5706bf523c0b63b57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16320bab7941e156d95a81e560eecd04 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a16320bab7941e156d95a81e560eecd04">download_range_to_stream_async</a> (concurrency::streams::ostream target, utility::size64_t offset, utility::size64_t length, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a16320bab7941e156d95a81e560eecd04 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download a range of bytes in a blob to a stream.  <a href="#a16320bab7941e156d95a81e560eecd04">More...</a><br /></td></tr>
<tr class="separator:a16320bab7941e156d95a81e560eecd04 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746d548ddeb67fade11440a661836e3e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a746d548ddeb67fade11440a661836e3e">download_to_file</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:a746d548ddeb67fade11440a661836e3e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the contents of a blob to a file.  <a href="#a746d548ddeb67fade11440a661836e3e">More...</a><br /></td></tr>
<tr class="separator:a746d548ddeb67fade11440a661836e3e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdb5bf7615e871144736806fe1239d1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aabdb5bf7615e871144736806fe1239d1">download_to_file</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aabdb5bf7615e871144736806fe1239d1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads the contents of a blob to a file.  <a href="#aabdb5bf7615e871144736806fe1239d1">More...</a><br /></td></tr>
<tr class="separator:aabdb5bf7615e871144736806fe1239d1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d5ee00acd5bea06be49b1eff91da08 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a16d5ee00acd5bea06be49b1eff91da08">download_to_file_async</a> (const utility::string_t &amp;path)</td></tr>
<tr class="memdesc:a16d5ee00acd5bea06be49b1eff91da08 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the contents of a blob to a file.  <a href="#a16d5ee00acd5bea06be49b1eff91da08">More...</a><br /></td></tr>
<tr class="separator:a16d5ee00acd5bea06be49b1eff91da08 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd624727c6c02bd707640817405a9578 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#abd624727c6c02bd707640817405a9578">download_to_file_async</a> (const utility::string_t &amp;path, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:abd624727c6c02bd707640817405a9578 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to download the contents of a blob to a file.  <a href="#abd624727c6c02bd707640817405a9578">More...</a><br /></td></tr>
<tr class="separator:abd624727c6c02bd707640817405a9578 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74329eae7d192f5b51bfd2de0f37080 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aa74329eae7d192f5b51bfd2de0f37080">start_copy_from_blob</a> (const web::http::uri &amp;source)</td></tr>
<tr class="memdesc:aa74329eae7d192f5b51bfd2de0f37080 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#aa74329eae7d192f5b51bfd2de0f37080">More...</a><br /></td></tr>
<tr class="separator:aa74329eae7d192f5b51bfd2de0f37080 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc801b25a39200a682c3acc79d600cde inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#afc801b25a39200a682c3acc79d600cde">start_copy_from_blob</a> (const web::http::uri &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:afc801b25a39200a682c3acc79d600cde inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#afc801b25a39200a682c3acc79d600cde">More...</a><br /></td></tr>
<tr class="separator:afc801b25a39200a682c3acc79d600cde inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d64ad09bca97615f0ec5b9fe0a742d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af3d64ad09bca97615f0ec5b9fe0a742d">start_copy_from_blob</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source)</td></tr>
<tr class="memdesc:af3d64ad09bca97615f0ec5b9fe0a742d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#af3d64ad09bca97615f0ec5b9fe0a742d">More...</a><br /></td></tr>
<tr class="separator:af3d64ad09bca97615f0ec5b9fe0a742d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328e075cbb7ea7ffbbabfa7e043f4ec6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a328e075cbb7ea7ffbbabfa7e043f4ec6">start_copy_from_blob</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a328e075cbb7ea7ffbbabfa7e043f4ec6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a328e075cbb7ea7ffbbabfa7e043f4ec6">More...</a><br /></td></tr>
<tr class="separator:a328e075cbb7ea7ffbbabfa7e043f4ec6 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aae281bd0a3e26f5866662403224cc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a03aae281bd0a3e26f5866662403224cc">start_copy_from_blob_async</a> (const web::http::uri &amp;source)</td></tr>
<tr class="memdesc:a03aae281bd0a3e26f5866662403224cc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a03aae281bd0a3e26f5866662403224cc">More...</a><br /></td></tr>
<tr class="separator:a03aae281bd0a3e26f5866662403224cc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf583ffefcf5ed448acf2cec2fd2cae5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#acf583ffefcf5ed448acf2cec2fd2cae5">start_copy_from_blob_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source)</td></tr>
<tr class="memdesc:acf583ffefcf5ed448acf2cec2fd2cae5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#acf583ffefcf5ed448acf2cec2fd2cae5">More...</a><br /></td></tr>
<tr class="separator:acf583ffefcf5ed448acf2cec2fd2cae5 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6a5a6e68536689a2009581def89d10 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aec6a5a6e68536689a2009581def89d10">start_copy_from_blob_async</a> (const web::http::uri &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:aec6a5a6e68536689a2009581def89d10 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#aec6a5a6e68536689a2009581def89d10">More...</a><br /></td></tr>
<tr class="separator:aec6a5a6e68536689a2009581def89d10 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211bbd691870afdfc53d712aedd78c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a7211bbd691870afdfc53d712aedd78c1">start_copy_from_blob_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a7211bbd691870afdfc53d712aedd78c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a7211bbd691870afdfc53d712aedd78c1">More...</a><br /></td></tr>
<tr class="separator:a7211bbd691870afdfc53d712aedd78c1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4ce1e82f1a11073ec9186d0a5697fe inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aaa4ce1e82f1a11073ec9186d0a5697fe">start_copy</a> (const web::http::uri &amp;source)</td></tr>
<tr class="memdesc:aaa4ce1e82f1a11073ec9186d0a5697fe inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#aaa4ce1e82f1a11073ec9186d0a5697fe">More...</a><br /></td></tr>
<tr class="separator:aaa4ce1e82f1a11073ec9186d0a5697fe inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b64239a2a2980e5a3b65fd97414e57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af1b64239a2a2980e5a3b65fd97414e57">start_copy</a> (const web::http::uri &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:af1b64239a2a2980e5a3b65fd97414e57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#af1b64239a2a2980e5a3b65fd97414e57">More...</a><br /></td></tr>
<tr class="separator:af1b64239a2a2980e5a3b65fd97414e57 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71060dedd5824f197cf077eb10348857 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a71060dedd5824f197cf077eb10348857">start_copy</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source)</td></tr>
<tr class="memdesc:a71060dedd5824f197cf077eb10348857 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a71060dedd5824f197cf077eb10348857">More...</a><br /></td></tr>
<tr class="separator:a71060dedd5824f197cf077eb10348857 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b52b391d3365bc9eee6cffd877f2e87 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0b52b391d3365bc9eee6cffd877f2e87">start_copy</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a0b52b391d3365bc9eee6cffd877f2e87 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a0b52b391d3365bc9eee6cffd877f2e87">More...</a><br /></td></tr>
<tr class="separator:a0b52b391d3365bc9eee6cffd877f2e87 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a36798517ab8546481477522bb56e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aea3a36798517ab8546481477522bb56e">start_copy</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__file.html">cloud_file</a> &amp;source)</td></tr>
<tr class="memdesc:aea3a36798517ab8546481477522bb56e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a file's contents, properties, and metadata to a new blob.  <a href="#aea3a36798517ab8546481477522bb56e">More...</a><br /></td></tr>
<tr class="separator:aea3a36798517ab8546481477522bb56e inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6c45c9cfe65100d4c43cac7422065d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#abe6c45c9cfe65100d4c43cac7422065d">start_copy</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__file.html">cloud_file</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1file__access__condition.html">file_access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:abe6c45c9cfe65100d4c43cac7422065d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an operation to copy a file's contents, properties, and metadata to a new blob.  <a href="#abe6c45c9cfe65100d4c43cac7422065d">More...</a><br /></td></tr>
<tr class="separator:abe6c45c9cfe65100d4c43cac7422065d inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0ef7a4db3e53cb3f0af88bfb396076 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#afe0ef7a4db3e53cb3f0af88bfb396076">start_copy_async</a> (const web::http::uri &amp;source)</td></tr>
<tr class="memdesc:afe0ef7a4db3e53cb3f0af88bfb396076 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#afe0ef7a4db3e53cb3f0af88bfb396076">More...</a><br /></td></tr>
<tr class="separator:afe0ef7a4db3e53cb3f0af88bfb396076 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed4d6d079959f88a66a79389fdaac50 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a2ed4d6d079959f88a66a79389fdaac50">start_copy_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source)</td></tr>
<tr class="memdesc:a2ed4d6d079959f88a66a79389fdaac50 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a2ed4d6d079959f88a66a79389fdaac50">More...</a><br /></td></tr>
<tr class="separator:a2ed4d6d079959f88a66a79389fdaac50 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ce142e07716cfa7b7c45012ce4d134 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae8ce142e07716cfa7b7c45012ce4d134">start_copy_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__file.html">cloud_file</a> &amp;source)</td></tr>
<tr class="memdesc:ae8ce142e07716cfa7b7c45012ce4d134 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a file's contents, properties, and metadata to a new blob.  <a href="#ae8ce142e07716cfa7b7c45012ce4d134">More...</a><br /></td></tr>
<tr class="separator:ae8ce142e07716cfa7b7c45012ce4d134 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f223af504c197f703243864a5e90e7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af8f223af504c197f703243864a5e90e7">start_copy_async</a> (const web::http::uri &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:af8f223af504c197f703243864a5e90e7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#af8f223af504c197f703243864a5e90e7">More...</a><br /></td></tr>
<tr class="separator:af8f223af504c197f703243864a5e90e7 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bff5240fe154cd734312b1bbecf6980 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a4bff5240fe154cd734312b1bbecf6980">start_copy_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a4bff5240fe154cd734312b1bbecf6980 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a blob's contents, properties, and metadata to a new blob.  <a href="#a4bff5240fe154cd734312b1bbecf6980">More...</a><br /></td></tr>
<tr class="separator:a4bff5240fe154cd734312b1bbecf6980 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383804587d5b7ed8e0e11f85c76b62a9 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a383804587d5b7ed8e0e11f85c76b62a9">start_copy_async</a> (const <a class="el" href="classazure_1_1storage_1_1cloud__file.html">cloud_file</a> &amp;source, const <a class="el" href="classazure_1_1storage_1_1file__access__condition.html">file_access_condition</a> &amp;source_condition, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;destination_condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a383804587d5b7ed8e0e11f85c76b62a9 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to begin to copy a file's contents, properties, and metadata to a new blob.  <a href="#a383804587d5b7ed8e0e11f85c76b62a9">More...</a><br /></td></tr>
<tr class="separator:a383804587d5b7ed8e0e11f85c76b62a9 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd60ac7b8f579254311186123ac4c56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a1bd60ac7b8f579254311186123ac4c56">abort_copy</a> (const utility::string_t &amp;copy_id) const </td></tr>
<tr class="memdesc:a1bd60ac7b8f579254311186123ac4c56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts an ongoing blob copy operation.  <a href="#a1bd60ac7b8f579254311186123ac4c56">More...</a><br /></td></tr>
<tr class="separator:a1bd60ac7b8f579254311186123ac4c56 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a3417ca19e591f34a7c47729d8bb66 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ac7a3417ca19e591f34a7c47729d8bb66">abort_copy</a> (const utility::string_t &amp;copy_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:ac7a3417ca19e591f34a7c47729d8bb66 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts an ongoing blob copy operation.  <a href="#ac7a3417ca19e591f34a7c47729d8bb66">More...</a><br /></td></tr>
<tr class="separator:ac7a3417ca19e591f34a7c47729d8bb66 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6acbc4520ef833ec05fca2a923edd0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a7b6acbc4520ef833ec05fca2a923edd0">abort_copy_async</a> (const utility::string_t &amp;copy_id) const </td></tr>
<tr class="memdesc:a7b6acbc4520ef833ec05fca2a923edd0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to abort an ongoing blob copy operation.  <a href="#a7b6acbc4520ef833ec05fca2a923edd0">More...</a><br /></td></tr>
<tr class="separator:a7b6acbc4520ef833ec05fca2a923edd0 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e97ec3e13cf07bacb98476eb6ab98f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af9e97ec3e13cf07bacb98476eb6ab98f">abort_copy_async</a> (const utility::string_t &amp;copy_id, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context) const </td></tr>
<tr class="memdesc:af9e97ec3e13cf07bacb98476eb6ab98f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to abort an ongoing blob copy operation.  <a href="#af9e97ec3e13cf07bacb98476eb6ab98f">More...</a><br /></td></tr>
<tr class="separator:af9e97ec3e13cf07bacb98476eb6ab98f inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc3f216b8b2d92ccf0e169da822156 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#adfcc3f216b8b2d92ccf0e169da822156">create_snapshot</a> ()</td></tr>
<tr class="memdesc:adfcc3f216b8b2d92ccf0e169da822156 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a snapshot of the blob.  <a href="#adfcc3f216b8b2d92ccf0e169da822156">More...</a><br /></td></tr>
<tr class="separator:adfcc3f216b8b2d92ccf0e169da822156 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25903b80d59053f731e61e748db0cd82 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a25903b80d59053f731e61e748db0cd82">create_snapshot</a> (cloud_metadata <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a06a94b1511f1d7453f1952060cdafcdb">metadata</a>, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a25903b80d59053f731e61e748db0cd82 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a snapshot of the blob.  <a href="#a25903b80d59053f731e61e748db0cd82">More...</a><br /></td></tr>
<tr class="separator:a25903b80d59053f731e61e748db0cd82 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5452a5b4c514e5bbe3355c36182643a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">pplx::task&lt; <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">azure::storage::cloud_blob</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a5452a5b4c514e5bbe3355c36182643a1">create_snapshot_async</a> ()</td></tr>
<tr class="memdesc:a5452a5b4c514e5bbe3355c36182643a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to create a snapshot of the blob.  <a href="#a5452a5b4c514e5bbe3355c36182643a1">More...</a><br /></td></tr>
<tr class="separator:a5452a5b4c514e5bbe3355c36182643a1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e024ab2159cb47d7bc616ee5879470 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">WASTORAGE_API pplx::task&lt; <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">azure::storage::cloud_blob</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a94e024ab2159cb47d7bc616ee5879470">create_snapshot_async</a> (cloud_metadata <a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a06a94b1511f1d7453f1952060cdafcdb">metadata</a>, const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;condition, const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;options, <a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a> context)</td></tr>
<tr class="memdesc:a94e024ab2159cb47d7bc616ee5879470 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intitiates an asynchronous operation to create a snapshot of the blob.  <a href="#a94e024ab2159cb47d7bc616ee5879470">More...</a><br /></td></tr>
<tr class="separator:a94e024ab2159cb47d7bc616ee5879470 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64ac047da20e482706334ddc1c1cec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classazure_1_1storage_1_1cloud__blob__client.html">cloud_blob_client</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a5e64ac047da20e482706334ddc1c1cec">service_client</a> () const </td></tr>
<tr class="memdesc:a5e64ac047da20e482706334ddc1c1cec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classazure_1_1storage_1_1cloud__blob__client.html" title="Provides a client-side logical representation of the Windows Azure Blob Service. This client is used ...">azure::storage::cloud_blob_client</a> object that represents the Blob service.  <a href="#a5e64ac047da20e482706334ddc1c1cec">More...</a><br /></td></tr>
<tr class="separator:a5e64ac047da20e482706334ddc1c1cec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d0c06689cabee13539f2dec1c309fb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classazure_1_1storage_1_1cloud__blob__container.html">cloud_blob_container</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#ae6d0c06689cabee13539f2dec1c309fb">container</a> () const </td></tr>
<tr class="memdesc:ae6d0c06689cabee13539f2dec1c309fb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an <a class="el" href="classazure_1_1storage_1_1cloud__blob__container.html" title="Represents a container in the Windows Azure Blob service. ">azure::storage::cloud_blob_container</a> object representing the blob's container.  <a href="#ae6d0c06689cabee13539f2dec1c309fb">More...</a><br /></td></tr>
<tr class="separator:ae6d0c06689cabee13539f2dec1c309fb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5837a2fbbf39fa5aa4ac30adde3829ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classazure_1_1storage_1_1cloud__blob__properties.html">cloud_blob_properties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a5837a2fbbf39fa5aa4ac30adde3829ec">properties</a> ()</td></tr>
<tr class="memdesc:a5837a2fbbf39fa5aa4ac30adde3829ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blob's system properties.  <a href="#a5837a2fbbf39fa5aa4ac30adde3829ec">More...</a><br /></td></tr>
<tr class="separator:a5837a2fbbf39fa5aa4ac30adde3829ec inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6a3a9e838f4a86ad6fc651275a2643 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classazure_1_1storage_1_1cloud__blob__properties.html">cloud_blob_properties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#afd6a3a9e838f4a86ad6fc651275a2643">properties</a> () const </td></tr>
<tr class="memdesc:afd6a3a9e838f4a86ad6fc651275a2643 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blob's system properties.  <a href="#afd6a3a9e838f4a86ad6fc651275a2643">More...</a><br /></td></tr>
<tr class="separator:afd6a3a9e838f4a86ad6fc651275a2643 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a94b1511f1d7453f1952060cdafcdb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">cloud_metadata &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a06a94b1511f1d7453f1952060cdafcdb">metadata</a> ()</td></tr>
<tr class="memdesc:a06a94b1511f1d7453f1952060cdafcdb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user-defined metadata for the blob.  <a href="#a06a94b1511f1d7453f1952060cdafcdb">More...</a><br /></td></tr>
<tr class="separator:a06a94b1511f1d7453f1952060cdafcdb inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071e84db79c1b33ae83a313639ca307b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const cloud_metadata &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a071e84db79c1b33ae83a313639ca307b">metadata</a> () const </td></tr>
<tr class="memdesc:a071e84db79c1b33ae83a313639ca307b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user-defined metadata for the blob.  <a href="#a071e84db79c1b33ae83a313639ca307b">More...</a><br /></td></tr>
<tr class="separator:a071e84db79c1b33ae83a313639ca307b inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c895693f527a1148fa6abc8672c626 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const utility::string_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a68c895693f527a1148fa6abc8672c626">snapshot_time</a> () const </td></tr>
<tr class="memdesc:a68c895693f527a1148fa6abc8672c626 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the date and time that the blob snapshot was taken, if this blob is a snapshot.  <a href="#a68c895693f527a1148fa6abc8672c626">More...</a><br /></td></tr>
<tr class="separator:a68c895693f527a1148fa6abc8672c626 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd6a81bce6b97280aab480254d53753 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#adfd6a81bce6b97280aab480254d53753">is_snapshot</a> () const </td></tr>
<tr class="memdesc:adfd6a81bce6b97280aab480254d53753 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether this blob is a snapshot.  <a href="#adfd6a81bce6b97280aab480254d53753">More...</a><br /></td></tr>
<tr class="separator:adfd6a81bce6b97280aab480254d53753 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43375ce4bc16944e75292715a480fdc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classazure_1_1storage_1_1copy__state.html">azure::storage::copy_state</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#af43375ce4bc16944e75292715a480fdc">copy_state</a> () const </td></tr>
<tr class="memdesc:af43375ce4bc16944e75292715a480fdc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the most recent or pending copy operation.  <a href="#af43375ce4bc16944e75292715a480fdc">More...</a><br /></td></tr>
<tr class="separator:af43375ce4bc16944e75292715a480fdc inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0552c5a58385f21f3c86ea9b823ca0b1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a0552c5a58385f21f3c86ea9b823ca0b1">uri</a> () const </td></tr>
<tr class="memdesc:a0552c5a58385f21f3c86ea9b823ca0b1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blob URI for all locations.  <a href="#a0552c5a58385f21f3c86ea9b823ca0b1">More...</a><br /></td></tr>
<tr class="separator:a0552c5a58385f21f3c86ea9b823ca0b1 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376671fe096065bad4ed137b93d26b06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">const utility::string_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a376671fe096065bad4ed137b93d26b06">name</a> () const </td></tr>
<tr class="memdesc:a376671fe096065bad4ed137b93d26b06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blob's name.  <a href="#a376671fe096065bad4ed137b93d26b06">More...</a><br /></td></tr>
<tr class="separator:a376671fe096065bad4ed137b93d26b06 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa717120e37ba465f6188d0e2e6574710 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">blob_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#aa717120e37ba465f6188d0e2e6574710">type</a> () const </td></tr>
<tr class="memdesc:aa717120e37ba465f6188d0e2e6574710 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the blob.  <a href="#aa717120e37ba465f6188d0e2e6574710">More...</a><br /></td></tr>
<tr class="separator:aa717120e37ba465f6188d0e2e6574710 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6973fb154ddc4366d5c27075926218 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classazure_1_1storage_1_1cloud__blob.html#a8a6973fb154ddc4366d5c27075926218">is_valid</a> () const </td></tr>
<tr class="memdesc:a8a6973fb154ddc4366d5c27075926218 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <a class="el" href="classazure_1_1storage_1_1cloud__blob.html" title="A class for Windows Azure blob types. The azure::storage::cloud_block_blob and azure::storage::cloud_...">azure::storage::cloud_blob</a> object is valid.  <a href="#a8a6973fb154ddc4366d5c27075926218">More...</a><br /></td></tr>
<tr class="separator:a8a6973fb154ddc4366d5c27075926218 inherit pub_methods_classazure_1_1storage_1_1cloud__blob"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a Windows Azure append blob. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad38afb33d45bc6ae56ac00a802ad87bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">azure::storage::cloud_append_blob::cloud_append_blob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class. </p>

</div>
</div>
<a class="anchor" id="aa852aabfcdd284ca06e4824a3088115d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">azure::storage::cloud_append_blob::cloud_append_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a>&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A <a class="el" href="classazure_1_1storage_1_1storage__uri.html" title="Contains the URIs for both the primary and secondary locations of a Windows Azure Storage resource...">storage_uri</a> object containing the absolute URI to the blob for all locations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace8424620abebc620726cd7c5a11c51e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">azure::storage::cloud_append_blob::cloud_append_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a>&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a>&#160;</td>
          <td class="paramname"><em>credentials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A <a class="el" href="classazure_1_1storage_1_1storage__uri.html" title="Contains the URIs for both the primary and secondary locations of a Windows Azure Storage resource...">storage_uri</a> object containing the absolute URI to the blob for all locations.</td></tr>
    <tr><td class="paramname">credentials</td><td>The <a class="el" href="classazure_1_1storage_1_1storage__credentials.html" title="Represents a set of credentials used to authenticate access to a Windows Azure storage account...">storage_credentials</a> to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2576168deaad055d2d15169dba3dd00a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">azure::storage::cloud_append_blob::cloud_append_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1storage__uri.html">storage_uri</a>&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>snapshot_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1storage__credentials.html">storage_credentials</a>&#160;</td>
          <td class="paramname"><em>credentials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class using an absolute URI to the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A <a class="el" href="classazure_1_1storage_1_1storage__uri.html" title="Contains the URIs for both the primary and secondary locations of a Windows Azure Storage resource...">storage_uri</a> object containing the absolute URI to the blob for all locations.</td></tr>
    <tr><td class="paramname">snapshot_time</td><td>The snapshot timestamp, if the blob is a snapshot.</td></tr>
    <tr><td class="paramname">credentials</td><td>The <a class="el" href="classazure_1_1storage_1_1storage__credentials.html" title="Represents a set of credentials used to authenticate access to a Windows Azure storage account...">storage_credentials</a> to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa791ddcad0cebc6803c11b68f7652dd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">azure::storage::cloud_append_blob::cloud_append_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1cloud__blob.html">cloud_blob</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classazure_1_1storage_1_1cloud__append__blob.html" title="Represents a Windows Azure append blob. ">azure::storage::cloud_append_blob</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Reference to the blob.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a49be5032bc5e89877bba6755c64a9ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t azure::storage::cloud_append_blob::append_block </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_md5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commits a new block of data to the end of the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_data</td><td>A stream that provides the data for the block.</td></tr>
    <tr><td class="paramname">content_md5</td><td>An optional hash value that will be used to to ensure transactional integrity for the block. May be an empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in bytes at which the block was committed to.</dd></dl>

</div>
</div>
<a class="anchor" id="a1d200778a2931d86aff6ebd72110a3f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t azure::storage::cloud_append_blob::append_block </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_md5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commits a new block of data to the end of the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_data</td><td>A stream that provides the data for the block.</td></tr>
    <tr><td class="paramname">content_md5</td><td>An optional hash value that will be used to to ensure transactional integrity for the block. May be an empty string. </td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in bytes at which the block was committed to.</dd></dl>

</div>
</div>
<a class="anchor" id="a65c9de880a1d8f39f890484f59c4949d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;int64_t&gt; azure::storage::cloud_append_blob::append_block_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_md5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to commit a new block of data to the end of the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_data</td><td>A stream that provides the data for the block.</td></tr>
    <tr><td class="paramname">content_md5</td><td>An optional hash value that will be used to to ensure transactional integrity for the block. May be an empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a19595e2136a254a6b131752254d821af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;int64_t&gt; azure::storage::cloud_append_blob::append_block_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_md5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to commit a new block of data to the end of the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_data</td><td>A stream that provides the data for the block.</td></tr>
    <tr><td class="paramname">content_md5</td><td>An optional hash value that will be used to to ensure transactional integrity for the block. May be an empty string. </td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a58a9a7fb0d6ba66d25e52dd7a417ea83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_file </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5054e49a4a635cc72e4b3159e7a5c1aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_file </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83576fa3701a19a6dcdc29ee56f0b178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_file_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a5515d772566e9ce8f77189c4d9534b5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_file_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a file to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a7f69ec049af3605909d1022c95c70dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abec568217a8fbcb306a1a77e266a627a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45c92060a87b7cceb68c917feb9dd96a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaac0123c73a8a41e70b789c16fa84e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7ecdc93d293d8cca8c816b4c8cdf818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a43382935d83ba8d62e45dc4e93986b20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="acfe9afce0f8c5e5116729db10d74703a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a8cbc6364c5ba9d3f41f545b5a5442f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a stream to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A concurrency::streams::istream object providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a9086d6dbe7040fe936d1822d72d6aa45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_text </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to append.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6e12358fa5240ec671ebcca5955e082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::append_text </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to append.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35445bc882a0fa3eefffe7b05f59692b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_text_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a17e86891294050a41c03ba6cb1b137f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::append_text_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an asynchronous operation to append a string of text to an append blob. This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks which does not work in a multiple writer scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to append.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="aea3c9470de3853b0546074c5162d44d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::create_or_replace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a> </p>

</div>
</div>
<a class="anchor" id="a5846f51c58f062a8ee2fd9eb2106f31c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::create_or_replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a359929efe289961523d8b4c77c68f80d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::create_or_replace_async </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to create an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a> </p>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="ae5f171f68a8b3e6791015fd7470f26d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::create_or_replace_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to create an empty append blob. If the blob already exists, this will replace it. To avoid overwriting and instead throw an error, please pass in an <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> parameter generated using <a class="el" href="classazure_1_1storage_1_1access__condition.html#ad27ea80f917b42f32794eacf6879a299" title="Generates an access condition such that an operation will be performed only if the resource does not ...">azure::storage::access_condition::generate_if_not_exists_condition</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a2ebdb8cbf63957dd9559245906bcada9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t azure::storage::cloud_append_blob::download_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downloads the blob's contents as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>The contents of the blob, as a string.</dd></dl>

</div>
</div>
<a class="anchor" id="afcfb3279be89151f0b1d609c28e30dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t azure::storage::cloud_append_blob::download_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downloads the blob's contents as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the blob, as a string.</dd></dl>

</div>
</div>
<a class="anchor" id="a5ed87834aff0d5841f841819e449c01a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;utility::string_t&gt; azure::storage::cloud_append_blob::download_text_async </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to download the blob's contents as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object of type utility::string_t that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="ab04102e7b213540366305128d136bace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;utility::string_t&gt; azure::storage::cloud_append_blob::download_text_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to download the blob's contents as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object of type utility::string_t that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a6b41d0431d3a1f1070d9e8447d2706c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::ostream azure::storage::cloud_append_blob::open_write </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a stream for writing to the append blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_new</td><td>Use <code>true</code> to create a new append blob or overwrite an existing one, <code>false</code> to append to an existing blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream to be used for writing to the blob.</dd></dl>

</div>
</div>
<a class="anchor" id="a1c9efc50cec8f148f92d51bcef84a5e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::ostream azure::storage::cloud_append_blob::open_write </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a stream for writing to the append blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_new</td><td>Use <code>true</code> to create a new append blob or overwrite an existing one, <code>false</code> to append to an existing blob.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream to be used for writing to the blob.</dd></dl>

</div>
</div>
<a class="anchor" id="aab8f364d4bdff228ac2fc4a933f8fc54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;concurrency::streams::ostream&gt; azure::storage::cloud_append_blob::open_write_async </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to open a stream for writing to the append blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_new</td><td>Use <code>true</code> to create a new append blob or overwrite an existing one, <code>false</code> to append to an existing blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object of type concurrency::streams::ostream that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="a2c3bceea6c00ec3e6d2665460e8c2bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;concurrency::streams::ostream&gt; azure::storage::cloud_append_blob::open_write_async </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to open a stream for writing to the append blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_new</td><td>Use <code>true</code> to create a new append blob or overwrite an existing one, <code>false</code> to append to an existing blob.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object of type concurrency::streams::ostream that represents the current operation.</dd></dl>

</div>
</div>
<a class="anchor" id="ab8d4362965d671d35d4c6822f88b5ebe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_file </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a file to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_from_file method.</p>

</div>
</div>
<a class="anchor" id="ad1beb1978cefba669860e25b11e2638d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_file </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a file to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_file method.</p>

</div>
</div>
<a class="anchor" id="a83bfd277142b64109c37e2f3a1b2f9e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_file_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a file to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_from_file_async method.</p>

</div>
</div>
<a class="anchor" id="a6fa68bb751ccfb6d1a265e2b388d8085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_file_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a file to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_file_async method.</p>

</div>
</div>
<a class="anchor" id="a9505993bc8d6559a6149bd66f2c740a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream method.</p>

</div>
</div>
<a class="anchor" id="a46e102f4fc515419541c45571a424d0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream method.</p>

</div>
</div>
<a class="anchor" id="a7f3cd3393d65abeef634a651ea55f752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream method.</p>

</div>
</div>
<a class="anchor" id="aca5355dab1d95ac7c55a74079c675742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_from_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a stream to an append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream method.</p>

</div>
</div>
<a class="anchor" id="adb20ecfb00b74283a0dcf23d0f542411"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. </p>
<p>If you want to append data to an already existing blob, please look at append_from_stream_async method.</p>

</div>
</div>
<a class="anchor" id="a4f6df071e084aaaeb37c76c20331ea4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream_async method.</p>

</div>
</div>
<a class="anchor" id="a01110f02868596b9c541c0ca02f5e267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream_async method.</p>

</div>
</div>
<a class="anchor" id="aeeef628d4425a78d2a0803e7a03a5088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_from_stream_async </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intitiates an asynchronous operation to upload a stream to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The stream providing the blob content.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the source stream at its current position.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_from_stream_async method.</p>

</div>
</div>
<a class="anchor" id="a1b336d1a7093428b784b1fb381788e12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_text </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to upload.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_text method.</p>

</div>
</div>
<a class="anchor" id="a3db5f84da3a32b866cd4ec5662df067e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void azure::storage::cloud_append_blob::upload_text </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to upload.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_text method.</p>

</div>
</div>
<a class="anchor" id="ac64961de61d2b3ed8478b847ce9ca217"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_text_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to upload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks.</p>
<p>If you want to append data to an already existing blob, please look at append_text_async method.</p>

</div>
</div>
<a class="anchor" id="a0c94abec395af89096048ed11543c069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WASTORAGE_API pplx::task&lt;void&gt; azure::storage::cloud_append_blob::upload_text_async </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1access__condition.html">access_condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classazure_1_1storage_1_1blob__request__options.html">blob_request_options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classazure_1_1storage_1_1operation__context.html">operation_context</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads a string of text to the append blob. If the blob already exists on the service, it will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>A string containing the text to upload.</td></tr>
    <tr><td class="paramname">condition</td><td>An <a class="el" href="classazure_1_1storage_1_1access__condition.html" title="Represents a set of access conditions to be used for operations against the Blob service. ">azure::storage::access_condition</a> object that represents the access condition for the operation.</td></tr>
    <tr><td class="paramname">options</td><td>A <a class="el" href="classazure_1_1storage_1_1blob__request__options.html" title="Represents a set of timeout and retry policy options that may be specified on a request against the B...">azure::storage::blob_request_options</a> object that specifies additional options for the request.</td></tr>
    <tr><td class="paramname">context</td><td>An <a class="el" href="classazure_1_1storage_1_1operation__context.html" title="Represents the context for a request to the Windows Azure storage services, and provides additional r...">azure::storage::operation_context</a> object that represents the context for the current operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pplx::task object that represents the current operation.</dd></dl>
<p>This API should be used strictly in a single writer scenario because the API internally uses the append-offset conditional header to avoid duplicate blocks. If you are guaranteed to have a single writer scenario, please look at <a class="el" href="classazure_1_1storage_1_1blob__request__options.html#ad9cf92682f051e0ae8ed9b28c7dc3305" title="Gets the value that indicates whether a conditional failure should be absorbed on a retry attempt for...">azure::storage::blob_request_options::absorb_conditional_errors_on_retry</a> and see if setting this flag to <code>true</code> is acceptable for you.</p>
<p>If you want to append data to an already existing blob, please look at append_text_async method.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 8 2017 14:22:19 for Microsoft Azure Storage Client Library for C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
